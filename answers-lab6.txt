=== Q How did you structure your transmit implementation?
===   In particular, what do you do if the transmit ring is full?
We busy wait in kernel mode waiting for the DD bit to be set by hardware.

=== Q How did you structure your receive implementation?
===   In particular, what do you do if the receive queue is empty and a user
===   environment requests the next incoming packet?
When a user request ends in a recive request to an empty queue
the user will go to sleep by setting his env.env_status to ENV_NOT_RUNNABLE.
The user virtual address for the packet is saved - which implements the zero copy challenge for receive.
Each receive intrrupt adds the packet to a kernel fifo list of received packets.
After a network interrupt in trap_dispach, we loop over the environments
checking for the sleeping environment and trasfering the packet's page to the saved virutal addres of the environment.
If we didnt find any environment sleeping, the packets will simply wait until the user ask to receive them.

=== Q What does the web page served by JOS's web server say?
Cheesy web page!

=== Q How long approximately did it take you to do this lab?
30H
(only because of this **** bug!, sorry)

=== Q challenge num 1
Set the address to read from EEPROM and the READ bit
and wait for the hardware to write to the Data offset of the WR EEPROM register.

=== Q challenge num 2
Zero Copy Challenge!
For transmit, we keep the transmit buffer queue in user space, as a static variable in output.c.
We receive packets to transmit directly into the queue (via IPC), keeping track of the current position.
We then call the driver function to transmit it, which gets the page that stores the packet via
page lookup and handles the descriptor stuff.

For the receiving part, we keep a fifo list of received packets, when a user receives and
a packet is in the queue, it is mapped to the user's va of choice and removed from the list.
If the queue is empty, as described earlier we saved the user's va of choice in their struct env
and map a packet for them once it arrives.

=== Q challenge num 5
We chose to implement the chat server. Multiple client connections are supported
by forking upon a new connection. Reading from the new socket is done in this new client_handler environment.
An additional broadcast environment is created at start. All client_handlers send by ipc to the
broadcast environment the chat message buffer.
He then, by saving all connections(envid -> socket id), broadcast the message to all other sockets.
