=== This template file contains questions you need to answer.
=== Fill your answers on appropriate blank lines only.
=== Don't start any line with three equal signs "===".
=== Don't edit any lines starting from three equal signs.
=== Use C notation to write numbers: 42 for decimal, 0x2a for hexadecimal.
=== We may check most of the answers automatically, so "forty two" or
=== "26+16" won't work for this example. Spaces are mostly ignored, so
=== "  42  " is OK (without quotes of course). 
=== When asked to specify address & instruction, do it in the form of
=== gdb output "ADDRESS: INSTRUCTION", for example "0x7c26:  or  $0x1,%eax"
=== Don't make lines longer than 80 characters. You don't need to fit your
=== answer in a single line, you can start a new line at will.
=== However, when asked to fill "a table" make each table raw a single line.

=== Q How much disk space can be addressed by a single bitmap block
===   when size of a block is 4KB? (number in _bytes_)
134217728
=== Q How much disk space can be addressed by a single bitmap block
===   when size of a block is 512B? (number in _bytes_)
2097152
=== Q What is a maximum supported file size in JOS FS? (number in _bytes_)
4235264
=== Q Did you have to do anything else to ensure that the I/O
===   privilege setting is saved and restored properly when you
===   subsequently switch from one environment to another? Why? 
===   (free form)
No, the privilege level is stored and set automatically by hardware.
As we switch from the privileged environment the saved state is stored and referenced
by the environment trapframe pointer and later will be resumed as we switch back to this
specific environment. Thus any other environment will not have this privilege level.
=== Q How long approximately did it take you to do this lab?
===   (number of hours for all partners combined)
4:30
====================================================================
=== Q What challenge(s) have you chosen to implement? (specify
===   challenge numbers separated by spaces, if more than one)
4
=== Q If the challenge requires changing the kernel source, list the
===   files which you have changed/added during implementation.
===   (one file per line, relative to lab directory containing .git/)
lib/spawn.c
inc/lib.h
inc/syscall.h
lib/syscall.c
kern/syscall.c
kern/env.c
kern/env.h

=== Q Describe you solution.
===   (free form, up to 500 words, don't need to use all 500!)
We finally chose to implement exec as a combination of a system-call and
userspace function.
The user space function acts like spawn, creating a new process child
initialed to run the new program. the syscall then recieves the child's
envid and consumes his memory space by copying all page entries
at the same time removing the parent's entries.
Then copying the new childs trapframe and destroying his environment.
This results in transferring the curent environment memory space and registers
entirely.
Firstly, we also tried to implement a user space exec by coppying an exec function
to UTEMP and finishing the memory transition there. We somehow got into problems
with direct jumps and got unmotivated to come up with a solution.
